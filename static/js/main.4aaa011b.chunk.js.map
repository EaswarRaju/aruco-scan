{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["App","containerRef","useRef","canvasRef","videoRef","useState","mediaStream","setMediaStream","hasCapture","setHasCapture","animationFrame","setAnimationFrame","isAllMarkersDetected","detectedMarkers","markers","forEach","marker","id","allMarkersDetected","Object","keys","length","isFlipped","corners","y","alignDiffTop","Math","abs","alignDiffBottom","stopCamera","stream","getTracks","track","stop","startCamera","video","current","undefined","window","navigator","mediaDevices","getUserMedia","constraints","webkitGetUserMedia","mozGetUserMedia","Promise","resolve","reject","call","Error","then","srcObject","src","URL","createObjectURL","useEffect","canvas","width","offsetWidth","height","offsetHeight","stopCapture","cancelAnimationFrame","tick","readyState","HAVE_ENOUGH_DATA","context","getContext","drawImage","detector","AR","Detector","dataSets","index","tolerance","getImageData","i","data","avg","detect","getMarkers","markerPositions","startPointX","min","x","endPointX","max","startPointY","getCorners","startCapture","requestAnimationFrame","className","ref","autoPlay","playsInline","classNames","onClick","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.4aaa011b.chunk.js","sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\nimport { AR } from 'js-aruco';\nimport classNames from 'classnames';\nimport './App.scss';\n\nfunction App() {\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const videoRef = useRef(null);\n  const [mediaStream, setMediaStream] = useState(null);\n  const [hasCapture, setHasCapture] = useState(false);\n  const [animationFrame, setAnimationFrame] = useState(null);\n\n  const TOP_LEFT = 0;\n  const TOP_RIGHT = 1;\n  const BOTTOM_LEFT = 2;\n  const BOTTOM_RIGHT = 3;\n\n  const isAllMarkersDetected = (detectedMarkers) => {\n    const markers = {};\n    detectedMarkers.forEach((marker) => { markers[marker.id] = marker; });\n    const allMarkersDetected = Object.keys(markers).length === 4;\n    if (allMarkersDetected) {\n      const ORIENTATION_OFFSET = 25;\n      const isFlipped = markers[TOP_LEFT].corners[0].y > markers[BOTTOM_LEFT].corners[3].y;\n      const alignDiffTop = Math.abs(markers[TOP_RIGHT].corners[1].y - markers[TOP_LEFT].corners[0].y);\n      const alignDiffBottom = Math.abs(markers[BOTTOM_RIGHT].corners[2].y - markers[BOTTOM_LEFT].corners[3].y);\n      if (isFlipped || alignDiffTop > ORIENTATION_OFFSET || alignDiffBottom > ORIENTATION_OFFSET) {\n        return false;\n      }\n    }\n    return allMarkersDetected;\n  };\n\n  const getMarkers = () => {\n    const detector = new AR.Detector();\n    const MAX_TOLERANCE = 80;\n    const TOLERANCE_INTERVAL = 5;\n\n    const dataSets = [];\n    let index = 0;\n\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n\n    for (let tolerance = 0; tolerance <= MAX_TOLERANCE; tolerance += TOLERANCE_INTERVAL) {\n      dataSets[index] = context.getImageData(0, 0, canvas.width, canvas.height);\n      index++;\n    }\n\n    for (let i = 0; i < dataSets[0].data.length; i += 4) {\n      index = 0;\n      for (let tolerance = 0; tolerance <= MAX_TOLERANCE; tolerance += TOLERANCE_INTERVAL) {\n        const avg = (dataSets[index].data[i] + dataSets[index].data[i + 1] + dataSets[index].data[i + 2]) / 3;\n\n        dataSets[index].data[i] = avg < tolerance ? 0 : dataSets[index].data[i];\n        dataSets[index].data[i + 1] = avg < tolerance ? 0 : dataSets[index].data[i + 1];\n        dataSets[index].data[i + 2] = avg < tolerance ? 0 : dataSets[index].data[i + 2];\n        index++;\n      }\n    }\n\n    index = 0;\n\n    for (let tolerance = 0; tolerance <= MAX_TOLERANCE; tolerance += TOLERANCE_INTERVAL) {\n      const markers = detector.detect(dataSets[index]);\n\n      index++;\n\n      if (isAllMarkersDetected(markers)) {\n        return markers;\n      }\n    }\n    return false\n  };\n\n  const getCorners = (markers) => {\n    const markerPositions = {};\n\n    markers.forEach((marker) => { markerPositions[marker.id] = marker; });\n\n    const startPointX = Math.min(\n      markerPositions[TOP_LEFT].corners[0].x,\n      markerPositions[BOTTOM_LEFT].corners[3].x\n    );\n\n    const endPointX = Math.max(\n      markerPositions[TOP_RIGHT].corners[1].x,\n      markerPositions[BOTTOM_RIGHT].corners[2].x\n    );\n\n    const startPointY = Math.min(\n      markerPositions[TOP_LEFT].corners[0].y,\n      markerPositions[TOP_RIGHT].corners[1].y\n    );\n\n    const endPointY = Math.max(\n      markerPositions[BOTTOM_LEFT].corners[3].y,\n      markerPositions[BOTTOM_RIGHT].corners[2].y\n    );\n\n    return {\n      x: startPointX,\n      y: startPointY,\n      width: endPointX - startPointX,\n      height: endPointY - startPointY\n    };\n  };\n\n  const stopCamera = (stream) => {\n    if (stream) {\n      stream.getTracks().forEach(track => track.stop());\n    }\n  };\n\n  const startCamera = () => {\n    const video = videoRef.current;\n\n    if (window.navigator.mediaDevices === undefined) {\n      window.navigator.mediaDevices = {};\n    }\n\n    if (window.navigator.mediaDevices.getUserMedia === undefined) {\n      window.navigator.mediaDevices.getUserMedia = (constraints) => {\n        const getUserMedia = window.navigator.webkitGetUserMedia || window.navigator.mozGetUserMedia;\n        if (!getUserMedia) {\n          return Promise.reject(new Error('getUserMedia is not implemented in this browser'));\n        }\n\n        return new Promise((resolve, reject) => {\n          getUserMedia.call(window.navigator, constraints, resolve, reject);\n        });\n      };\n    }\n\n    window.navigator.mediaDevices\n      .getUserMedia({ video: true })\n      .then((stream) => {\n        if ('srcObject' in video) {\n          video.srcObject = stream;\n        } else {\n          video.src = window.URL.createObjectURL(stream);\n        }\n        setMediaStream(stream);\n      });\n  };\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    canvas.width = canvas.offsetWidth;\n    canvas.height = canvas.offsetHeight;\n\n    startCamera();\n  }, []);\n\n  const stopCapture = () => {\n    if (animationFrame !== null){\n      window.cancelAnimationFrame(animationFrame);\n    }\n  };\n\n  useEffect(() => {\n    if (mediaStream) {\n      const tick = () => {\n        if (mediaStream) {\n          {\n            const canvas = canvasRef.current;\n            const video = videoRef.current;\n            if (video && video.readyState === video.HAVE_ENOUGH_DATA) {\n              const context = canvas.getContext('2d');\n              context.drawImage(video, 0, 0, canvas.width, canvas.height);\n\n              const markers = getMarkers();\n    \n              if (markers) {\n                const corners = getCorners(markers);\n                context.drawImage(\n                  context.canvas,\n                  corners.x,\n                  corners.y,\n                  corners.width,\n                  corners.height,\n                  0,\n                  0,\n                  canvas.width,\n                  canvas.height\n                );\n                stopCamera(mediaStream);\n                setHasCapture(true);\n              } else {\n                startCapture();\n              }\n            } else {\n              startCapture();\n            }\n          };\n        }\n      }\n      const startCapture = () => {\n        stopCapture();\n        setAnimationFrame(window.requestAnimationFrame(tick));\n      };\n      startCapture();\n    }\n\n    return () => {\n      stopCamera(mediaStream);\n    };\n  }, [mediaStream]);\n  \n  return (\n    <div className=\"scan-edit\" ref={containerRef}>\n      <div className=\"scan-overlay\" />\n      <div className=\"scan-header\">\n        Align a section of your Mathletics Paper with the area below\n      </div>\n      <video className=\"hidden\" autoPlay playsInline ref={videoRef} />\n      <div className=\"camera-area\">\n        <canvas\n          className={classNames({\n            'has-capture': hasCapture\n          })}\n          ref={canvasRef}\n        />\n      </div>\n      {hasCapture &&\n        <button\n          className=\"btn-retake\"\n          onClick={() => {\n            setHasCapture(false);\n            startCamera();\n          }}\n        >\n          Rescan work\n        </button>\n      }\n      <div className=\"scan-footer\">\n        <button onClick={() => {\n          stopCapture();\n          stopCamera(mediaStream);\n        }}>Stop</button>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}