{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["App","containerRef","useRef","canvasRef","mirrorRef","videoRef","useState","mediaStream","setMediaStream","hasCapture","setHasCapture","tolerance","setTolerance","animationFrame","setAnimationFrame","showMirror","setShowMirror","showGreyScaled","setShowGreyScaled","stopCamera","stream","getTracks","forEach","track","stop","startCamera","video","current","undefined","window","navigator","mediaDevices","getUserMedia","constraints","webkitGetUserMedia","mozGetUserMedia","Promise","resolve","reject","call","Error","then","srcObject","src","URL","createObjectURL","useEffect","canvas","width","offsetWidth","height","offsetHeight","detector","AR","Detector","tick","readyState","HAVE_ENOUGH_DATA","context","getContext","drawImage","imageData","getImageData","console","log","i","data","length","avg","putImageData","markers","detect","detectedMarkers","marker","id","allMarkersDetected","Object","keys","isFlipped","corners","y","alignDiffTop","Math","abs","alignDiffBottom","isAllMarkersDetected","markerPositions","startPointX","min","x","endPointX","max","startPointY","getCorners","startCapture","cancelAnimationFrame","requestAnimationFrame","className","ref","autoPlay","playsInline","classNames","hidden","onClick","type","onChange","value","target","parseInt","name","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.846ccb90.chunk.js","sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\nimport { AR } from 'js-aruco';\nimport classNames from 'classnames';\nimport './App.scss';\n\nfunction App() {\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const mirrorRef = useRef(null);\n  const videoRef = useRef(null);\n  const [mediaStream, setMediaStream] = useState(null);\n  const [hasCapture, setHasCapture] = useState(false);\n  const [tolerance, setTolerance] = useState(40);\n  const [animationFrame, setAnimationFrame] = useState(null);\n  const [showMirror, setShowMirror] = useState(false);\n  const [showGreyScaled, setShowGreyScaled] = useState(false);\n\n  const TOP_LEFT = 0;\n  const TOP_RIGHT = 1;\n  const BOTTOM_LEFT = 2;\n  const BOTTOM_RIGHT = 3;\n\n  const isAllMarkersDetected = (detectedMarkers) => {\n    const markers = {};\n    detectedMarkers.forEach((marker) => { markers[marker.id] = marker; });\n    const allMarkersDetected = Object.keys(markers).length === 4;\n    if (allMarkersDetected) {\n      const ORIENTATION_OFFSET = 25;\n      const isFlipped = markers[TOP_LEFT].corners[0].y > markers[BOTTOM_LEFT].corners[3].y;\n      const alignDiffTop = Math.abs(markers[TOP_RIGHT].corners[1].y - markers[TOP_LEFT].corners[0].y);\n      const alignDiffBottom = Math.abs(markers[BOTTOM_RIGHT].corners[2].y - markers[BOTTOM_LEFT].corners[3].y);\n      if (isFlipped || alignDiffTop > ORIENTATION_OFFSET || alignDiffBottom > ORIENTATION_OFFSET) {\n        return false;\n      }\n    }\n    return allMarkersDetected;\n  };\n\n  const getCorners = (markers) => {\n    const markerPositions = {};\n\n    markers.forEach((marker) => { markerPositions[marker.id] = marker; });\n\n    const startPointX = Math.min(\n      markerPositions[TOP_LEFT].corners[0].x,\n      markerPositions[BOTTOM_LEFT].corners[3].x\n    );\n\n    const endPointX = Math.max(\n      markerPositions[TOP_RIGHT].corners[1].x,\n      markerPositions[BOTTOM_RIGHT].corners[2].x\n    );\n\n    const startPointY = Math.min(\n      markerPositions[TOP_LEFT].corners[0].y,\n      markerPositions[TOP_RIGHT].corners[1].y\n    );\n\n    const endPointY = Math.max(\n      markerPositions[BOTTOM_LEFT].corners[3].y,\n      markerPositions[BOTTOM_RIGHT].corners[2].y\n    );\n\n    return {\n      x: startPointX,\n      y: startPointY,\n      width: endPointX - startPointX,\n      height: endPointY - startPointY\n    };\n  };\n\n  const stopCamera = (stream) => {\n    if (stream) {\n      stream.getTracks().forEach(track => track.stop());\n    }\n  };\n\n  const startCamera = () => {\n    const video = videoRef.current;\n\n    if (window.navigator.mediaDevices === undefined) {\n      window.navigator.mediaDevices = {};\n    }\n\n    if (window.navigator.mediaDevices.getUserMedia === undefined) {\n      window.navigator.mediaDevices.getUserMedia = (constraints) => {\n        const getUserMedia = window.navigator.webkitGetUserMedia || window.navigator.mozGetUserMedia;\n        if (!getUserMedia) {\n          return Promise.reject(new Error('getUserMedia is not implemented in this browser'));\n        }\n\n        return new Promise((resolve, reject) => {\n          getUserMedia.call(window.navigator, constraints, resolve, reject);\n        });\n      };\n    }\n\n    window.navigator.mediaDevices\n      .getUserMedia({ video: true })\n      .then((stream) => {\n        if ('srcObject' in video) {\n          video.srcObject = stream;\n        } else {\n          video.src = window.URL.createObjectURL(stream);\n        }\n        setMediaStream(stream);\n      });\n  };\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    canvas.width = canvas.offsetWidth;\n    canvas.height = canvas.offsetHeight;\n\n    mirrorRef.current.width = canvas.width;\n    mirrorRef.current.height = canvas.height;\n\n    startCamera();\n  }, []);\n\n  const stopCapture = () => {\n    if (animationFrame !== null){\n      window.cancelAnimationFrame(animationFrame);\n    }\n  };\n\n  useEffect(() => {\n    if (mediaStream) {\n      const detector = new AR.Detector();\n      const tick = () => {\n        if (mediaStream) {\n          {\n            const canvas = canvasRef.current;\n            const video = videoRef.current;\n            if (video && video.readyState === video.HAVE_ENOUGH_DATA) {\n              const context = canvas.getContext('2d');\n              context.drawImage(video, 0, 0, canvas.width, canvas.height);\n              const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n    \n              console.log(tolerance);\n    \n              for (let i = 0; i < imageData.data.length; i += 4) {\n                const avg = (imageData.data[i] + imageData.data[i + 1] + imageData.data[i + 2]) / 3;\n    \n                imageData.data[i] = avg < tolerance ? 0 : (showGreyScaled ? avg : imageData.data[i]);\n                imageData.data[i + 1] = avg < tolerance ? 0 : (showGreyScaled ? avg : imageData.data[i + 1]);\n                imageData.data[i + 2] = avg < tolerance ? 0 : (showGreyScaled ? avg : imageData.data[i + 2]);\n              }\n    \n              const mirrorContext = mirrorRef.current.getContext('2d');\n              mirrorContext.putImageData(imageData, 0, 0, 0, 0, canvas.width, canvas.height);\n    \n              const markers = detector.detect(imageData);\n    \n              if (isAllMarkersDetected(markers)) {\n                const corners = getCorners(markers);\n                context.drawImage(\n                  context.canvas,\n                  corners.x,\n                  corners.y,\n                  corners.width,\n                  corners.height,\n                  0,\n                  0,\n                  canvas.width,\n                  canvas.height\n                );\n                stopCamera(mediaStream);\n                setHasCapture(true);\n              } else {\n                startCapture();\n              }\n            } else {\n              startCapture();\n            }\n          };\n        }\n      }\n      const startCapture = () => {\n        stopCapture();\n        setAnimationFrame(window.requestAnimationFrame(tick));\n      };\n      startCapture();\n    }\n\n    return () => {\n      stopCamera(mediaStream);\n    };\n  }, [mediaStream, showGreyScaled, tolerance]); // eslint-disable-line\n  \n  return (\n    <div className=\"scan-edit\" ref={containerRef}>\n      <div className=\"scan-overlay\" />\n      <div className=\"scan-header\">\n        Align a section of your Mathletics Paper with the area below\n      </div>\n      <video className=\"hidden\" autoPlay playsInline ref={videoRef} />\n      <div className=\"camera-area\">\n        <canvas\n          className={classNames({\n            'has-capture': hasCapture,\n            hidden: showMirror\n          })}\n          ref={canvasRef}\n        />\n        <canvas className={classNames({hidden: !showMirror})} ref={mirrorRef} />\n      </div>\n      {hasCapture &&\n        <button\n          className=\"btn-retake\"\n          onClick={() => {\n            setHasCapture(false);\n            startCamera();\n          }}\n        >\n          Rescan work\n        </button>\n      }\n      <div className=\"scan-footer\">\n        <label>\n          <span>Tolerance: </span>\n          <input type=\"text\" onChange={({ target: { value } }) => {\n            stopCamera(mediaStream);\n            setMediaStream(null);\n            window.cancelAnimationFrame(animationFrame);\n            setTolerance(parseInt(value, 10));\n            startCamera();\n          }} />\n        </label>\n        <label onClick={() => {\n          setShowMirror(false);\n        }}>\n          <input type=\"radio\" name=\"canvas\" />\n          <span>Original</span>\n        </label>\n        <label onClick={() => {\n          setShowMirror(true);\n        }}>\n          <input type=\"radio\" name=\"canvas\" />\n          <span>Mirror</span>\n        </label>\n        <label onClick={() => {\n          stopCamera(mediaStream);\n          setMediaStream(null);\n          window.cancelAnimationFrame(animationFrame);\n          setShowGreyScaled(false);\n          startCamera();\n        }}>\n          <input type=\"radio\" name=\"color\" />\n          <span>Color</span>\n        </label>\n        <label onClick={() => {\n          stopCamera(mediaStream);\n          setMediaStream(null);\n          window.cancelAnimationFrame(animationFrame);\n          setShowGreyScaled(true);\n          startCamera();\n        }}>\n          <input type=\"radio\" name=\"color\" />\n          <span>Mono</span>\n        </label>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}